import { EMPTY_OBJ, Events, controlledComponent, ensure, getComponentsAlias, hooks, init_shared_esm, internalComponents, isArray, isFunction, isNull, isObject, isString, isUndefined, noop, toCamelCase, toDashed, warn } from "./chunk-AFNOH6ET.js";
import { __esm, __export } from "./chunk-P7VEE7PG.js";
// node_modules/@tarojs/runtime/dist/runtime.esm.js
var runtime_esm_exports = {};
__export(runtime_esm_exports, {
    Current: ()=>Current,
    Events: ()=>Events,
    FormElement: ()=>FormElement,
    MutationObserver: ()=>MutationObserver,
    SVGElement: ()=>SVGElement,
    Style: ()=>Style,
    TaroElement: ()=>TaroElement,
    TaroEvent: ()=>TaroEvent,
    TaroNode: ()=>TaroNode,
    TaroRootElement: ()=>TaroRootElement,
    TaroText: ()=>TaroText,
    addLeadingSlash: ()=>addLeadingSlash,
    cancelAnimationFrame: ()=>_caf,
    createComponentConfig: ()=>createComponentConfig,
    createEvent: ()=>createEvent,
    createPageConfig: ()=>createPageConfig,
    createRecursiveComponentConfig: ()=>createRecursiveComponentConfig,
    document: ()=>document$1,
    eventCenter: ()=>eventCenter,
    eventHandler: ()=>eventHandler,
    eventSource: ()=>eventSource,
    getComputedStyle: ()=>getComputedStyle,
    getCurrentInstance: ()=>getCurrentInstance,
    getPageInstance: ()=>getPageInstance,
    hooks: ()=>hooks,
    hydrate: ()=>hydrate,
    incrementId: ()=>incrementId,
    injectPageInstance: ()=>injectPageInstance,
    navigator: ()=>nav,
    nextTick: ()=>nextTick,
    now: ()=>now,
    options: ()=>options,
    removePageInstance: ()=>removePageInstance,
    requestAnimationFrame: ()=>_raf,
    safeExecute: ()=>safeExecute,
    stringify: ()=>stringify,
    window: ()=>window$1
});
function logMutation(observer, record) {
    observer.records.push(record);
    if (!pendingMuatations) {
        pendingMuatations = true;
        Promise.resolve().then(()=>{
            pendingMuatations = false;
            observers.forEach((observer2)=>{
                return observer2.callback(observer2.takeRecords());
            });
        });
    }
}
function recordMutation(record) {
    observers.forEach((observer)=>{
        const { options: options2  } = observer;
        for(let t = record.target; t; t = t.parentNode){
            if (sidMatches(observer.target, t) && isConcerned(record, options2)) {
                logMutation(observer, record);
                break;
            }
            if (!options2.subtree) break;
        }
    });
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeName === COMMENT;
}
function isHasExtractProp(el) {
    const res = Object.keys(el.props).find((prop)=>{
        return !(/^(class|style|id)$/.test(prop) || prop.startsWith("data-"));
    });
    return Boolean(res);
}
function isParentBinded(node, type) {
    var _a;
    let res = false;
    while((node === null || node === void 0 ? void 0 : node.parentElement) && node.parentElement._path !== ROOT_STR){
        if ((_a = node.parentElement.__handlers[type]) === null || _a === void 0 ? void 0 : _a.length) {
            res = true;
            break;
        }
        node = node.parentElement;
    }
    return res;
}
function shortcutAttr(key) {
    switch(key){
        case STYLE:
            return "st";
        case ID:
            return UID;
        case CLASS:
            return "cl";
        default:
            return key;
    }
}
function extend(ctor, methodName, options2) {
    if (isFunction(options2)) {
        options2 = {
            value: options2
        };
    }
    Object.defineProperty(ctor.prototype, methodName, Object.assign({
        configurable: true,
        enumerable: true
    }, options2));
}
function getComponentsAlias2() {
    if (!componentsAlias$1) {
        componentsAlias$1 = getComponentsAlias(internalComponents);
    }
    return componentsAlias$1;
}
function hydrate(node) {
    if (!componentsAlias) {
        componentsAlias = getComponentsAlias2();
    }
    if (!SPECIAL_NODES) {
        SPECIAL_NODES = hooks.call("getSpecialNodes");
    }
    const nodeName = node.nodeName;
    if (isText(node)) {
        return {
            ["v"]: node.nodeValue,
            ["nn"]: componentsAlias[nodeName]._num
        };
    }
    const data = {
        ["nn"]: nodeName,
        sid: node.sid
    };
    if (node.uid !== node.sid) {
        data.uid = node.uid;
    }
    if (!node.isAnyEventBinded() && SPECIAL_NODES.indexOf(nodeName) > -1) {
        data["nn"] = `static-${nodeName}`;
        if (nodeName === VIEW && !isHasExtractProp(node)) {
            data["nn"] = PURE_VIEW;
        }
    }
    const { props  } = node;
    for(const prop in props){
        const propInCamelCase = toCamelCase(prop);
        if (!prop.startsWith("data-") && prop !== CLASS && prop !== STYLE && prop !== ID && propInCamelCase !== CATCHMOVE) {
            data[propInCamelCase] = props[prop];
        }
        if (nodeName === VIEW && propInCamelCase === CATCHMOVE && props[prop] !== false) {
            data["nn"] = CATCH_VIEW;
        }
    }
    let { childNodes  } = node;
    childNodes = childNodes.filter((node2)=>!isComment(node2));
    if (childNodes.length > 0) {
        data["cn"] = childNodes.map(hydrate);
    } else {
        data["cn"] = [];
    }
    if (node.className !== "") {
        data["cl"] = node.className;
    }
    const cssText = node.cssText;
    if (cssText !== "" && nodeName !== "swiper-item") {
        data["st"] = cssText;
    }
    hooks.call("modifyHydrateData", data);
    const nn = data["nn"];
    const componentAlias = componentsAlias[nn];
    if (componentAlias) {
        data["nn"] = componentAlias._num;
        for(const prop1 in data){
            if (prop1 in componentAlias) {
                data[componentAlias[prop1]] = data[prop1];
                delete data[prop1];
            }
        }
    }
    return data;
}
function combine(prefix, list, excludeSelf) {
    !excludeSelf && styleProperties.push(prefix);
    list.forEach((item)=>{
        styleProperties.push(prefix + item);
        if (prefix === WEBKIT) {
            styleProperties.push("Webkit" + item);
        }
    });
}
function recordCss(obj) {
    MutationObserver.record({
        type: "attributes",
        target: obj._element,
        attributeName: "style",
        oldValue: obj.cssText
    });
}
function enqueueUpdate(obj) {
    const element = obj._element;
    if (element._root) {
        element.enqueueUpdate({
            path: `${element._path}.${"st"}`,
            value: obj.cssText
        });
    }
}
function setStyle(newVal, styleKey) {
    warn(isString(newVal) && newVal.length > PROPERTY_THRESHOLD, `Style \u5C5E\u6027 ${styleKey} \u7684\u503C\u6570\u636E\u91CF\u8FC7\u5927\uFF0C\u53EF\u80FD\u4F1A\u5F71\u54CD\u6E32\u67D3\u6027\u80FD\uFF0C\u8003\u8651\u4F7F\u7528 CSS \u7C7B\u6216\u5176\u5B83\u65B9\u6848\u66FF\u4EE3\u3002`);
    const old = this[styleKey];
    if (old === newVal) return;
    !this._pending && recordCss(this);
    if (isNull(newVal) || isUndefined(newVal)) {
        this._usedStyleProp.delete(styleKey);
        delete this._value[styleKey];
    } else {
        this._usedStyleProp.add(styleKey);
        this._value[styleKey] = newVal;
    }
    !this._pending && enqueueUpdate(this);
}
function initStyle(ctor) {
    const properties = {};
    for(let i = 0; i < styleProperties.length; i++){
        const styleKey = styleProperties[i];
        properties[styleKey] = {
            get () {
                const val = this._value[styleKey];
                return isNull(val) || isUndefined(val) ? "" : val;
            },
            set (newVal) {
                setStyle.call(this, newVal, styleKey);
            }
        };
    }
    Object.defineProperties(ctor.prototype, properties);
}
function isCssVariable(propertyName) {
    return /^--/.test(propertyName);
}
function returnTrue() {
    return true;
}
function treeToArray(root, predict) {
    const array = [];
    const filter = predict !== null && predict !== void 0 ? predict : returnTrue;
    let object = root;
    while(object){
        if (object.nodeType === 1 && filter(object)) {
            array.push(object);
        }
        object = following(object, root);
    }
    return array;
}
function following(el, root) {
    const firstChild = el.firstChild;
    if (firstChild) {
        return firstChild;
    }
    let current = el;
    do {
        if (current === root) {
            return null;
        }
        const nextSibling = current.nextSibling;
        if (nextSibling) {
            return nextSibling;
        }
        current = current.parentElement;
    }while (current)
    return null;
}
function initPosition() {
    return {
        index: 0,
        column: 0,
        line: 0
    };
}
function feedPosition(position, str, len) {
    const start = position.index;
    const end = position.index = start + len;
    for(let i = start; i < end; i++){
        const char = str.charAt(i);
        if (char === "\n") {
            position.line++;
            position.column = 0;
        } else {
            position.column++;
        }
    }
}
function jumpPosition(position, str, end) {
    const len = end - position.index;
    return feedPosition(position, str, len);
}
function copyPosition(position) {
    return {
        index: position.index,
        line: position.line,
        column: position.column
    };
}
function isWhitespaceChar(char) {
    return whitespace.test(char);
}
function isEqualSignChar(char) {
    return equalSign.test(char);
}
function shouldBeIgnore(tagName) {
    const name = tagName.toLowerCase();
    if (options.html.skipElements.has(name)) {
        return true;
    }
    return false;
}
function findTextEnd(str, index) {
    while(true){
        const textEnd = str.indexOf("<", index);
        if (textEnd === -1) {
            return textEnd;
        }
        const char = str.charAt(textEnd + 1);
        if (char === "/" || char === "!" || alphanumeric.test(char)) {
            return textEnd;
        }
        index = textEnd + 1;
    }
}
function isWordEnd(cursor, wordBegin, html) {
    if (!isWhitespaceChar(html.charAt(cursor))) return false;
    const len = html.length;
    for(let i = cursor - 1; i > wordBegin; i--){
        const char = html.charAt(i);
        if (!isWhitespaceChar(char)) {
            if (isEqualSignChar(char)) return false;
            break;
        }
    }
    for(let i1 = cursor + 1; i1 < len; i1++){
        const char1 = html.charAt(i1);
        if (!isWhitespaceChar(char1)) {
            if (isEqualSignChar(char1)) return false;
            return true;
        }
    }
}
function unquote(str) {
    const car = str.charAt(0);
    const end = str.length - 1;
    const isQuoteStart = car === '"' || car === "'";
    if (isQuoteStart && car === str.charAt(end)) {
        return str.slice(1, end);
    }
    return str;
}
function getPreviousElement(el) {
    const parent = el.parentElement;
    if (!parent) return null;
    const prev = el.previousSibling;
    if (!prev) return null;
    if (prev.nodeType === 1) {
        return prev;
    } else {
        return getPreviousElement(prev);
    }
}
function sortStyles(styles) {
    return styles.sort((s1, s2)=>{
        const hundreds1 = getHundredsWeight(s1.selectorList);
        const hundreds2 = getHundredsWeight(s2.selectorList);
        if (hundreds1 !== hundreds2) return hundreds1 - hundreds2;
        const tens1 = getTensWeight(s1.selectorList);
        const tens2 = getTensWeight(s2.selectorList);
        if (tens1 !== tens2) return tens1 - tens2;
        const ones1 = getOnesWeight(s1.selectorList);
        const ones2 = getOnesWeight(s2.selectorList);
        return ones1 - ones2;
    });
}
function getHundredsWeight(selectors) {
    return selectors.reduce((pre, cur)=>pre + (cur.id ? 1 : 0), 0);
}
function getTensWeight(selectors) {
    return selectors.reduce((pre, cur)=>pre + cur.class.length + cur.attrs.length, 0);
}
function getOnesWeight(selectors) {
    return selectors.reduce((pre, cur)=>pre + (cur.tag ? 1 : 0), 0);
}
function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for(let i = 0; i < list.length; i++){
        map[list[i]] = true;
    }
    return expectsLowerCase ? (val)=>!!map[val.toLowerCase()] : (val)=>!!map[val];
}
function hasTerminalParent(tagName, stack) {
    const tagParents = closingTagAncestorBreakers[tagName];
    if (tagParents) {
        let currentIndex = stack.length - 1;
        while(currentIndex >= 0){
            const parentTagName = stack[currentIndex].tagName;
            if (parentTagName === tagName) {
                break;
            }
            if (tagParents && tagParents.includes(parentTagName)) {
                return true;
            }
            currentIndex--;
        }
    }
    return false;
}
function getTagName(tag) {
    if (options.html.renderHTMLTag) {
        return tag;
    }
    if (specialMiniElements[tag]) {
        return specialMiniElements[tag];
    } else if (isMiniElements(tag)) {
        return tag;
    } else if (isBlockElements(tag)) {
        return "view";
    } else if (isInlineElements(tag)) {
        return "text";
    }
    return "view";
}
function splitEqual(str) {
    const sep = "=";
    const idx = str.indexOf(sep);
    if (idx === -1) return [
        str
    ];
    const key = str.slice(0, idx).trim();
    const value = str.slice(idx + sep.length).trim();
    return [
        key,
        value
    ];
}
function format(children, document2, styleOptions, parent) {
    return children.filter((child)=>{
        if (child.type === "comment") {
            return false;
        } else if (child.type === "text") {
            return child.content !== "";
        }
        return true;
    }).map((child)=>{
        if (child.type === "text") {
            let text = document2.createTextNode(child.content);
            if (isFunction(options.html.transformText)) {
                text = options.html.transformText(text, child);
            }
            parent === null || parent === void 0 ? void 0 : parent.appendChild(text);
            return text;
        }
        const el = document2.createElement(getTagName(child.tagName));
        el.h5tagName = child.tagName;
        parent === null || parent === void 0 ? void 0 : parent.appendChild(el);
        if (!options.html.renderHTMLTag) {
            el.className = `h5-${child.tagName}`;
        }
        for(let i = 0; i < child.attributes.length; i++){
            const attr = child.attributes[i];
            const [key, value] = splitEqual(attr);
            if (key === "class") {
                el.className += " " + unquote(value);
            } else if (key[0] === "o" && key[1] === "n") {
                continue;
            } else {
                el.setAttribute(key, value == null ? true : unquote(value));
            }
        }
        const { styleTagParser , descendantList  } = styleOptions;
        const list = descendantList.slice();
        const style2 = styleTagParser.matchStyle(child.tagName, el, list);
        el.setAttribute("style", style2 + el.style.cssText);
        format(child.children, document2, {
            styleTagParser,
            descendantList: list
        }, el);
        if (isFunction(options.html.transformElement)) {
            return options.html.transformElement(el, child);
        }
        return el;
    });
}
function parser(html, document2) {
    const styleTagParser = new StyleTagParser();
    html = styleTagParser.extractStyle(html);
    const tokens = new Scaner(html).scan();
    const root = {
        tagName: "",
        children: [],
        type: "element",
        attributes: []
    };
    const state = {
        tokens,
        options,
        cursor: 0,
        stack: [
            root
        ]
    };
    parse(state);
    return format(root.children, document2, {
        styleTagParser,
        descendantList: Array(styleTagParser.styles.length).fill(0)
    });
}
function parse(state) {
    const { tokens , stack  } = state;
    let { cursor  } = state;
    const len = tokens.length;
    let nodes = stack[stack.length - 1].children;
    while(cursor < len){
        const token = tokens[cursor];
        if (token.type !== "tag-start") {
            nodes.push(token);
            cursor++;
            continue;
        }
        const tagToken = tokens[++cursor];
        cursor++;
        const tagName = tagToken.content.toLowerCase();
        if (token.close) {
            let index = stack.length;
            let shouldRewind = false;
            while(--index > -1){
                if (stack[index].tagName === tagName) {
                    shouldRewind = true;
                    break;
                }
            }
            while(cursor < len){
                const endToken = tokens[cursor];
                if (endToken.type !== "tag-end") break;
                cursor++;
            }
            if (shouldRewind) {
                stack.splice(index);
                break;
            } else {
                continue;
            }
        }
        const isClosingTag = options.html.closingElements.has(tagName);
        let shouldRewindToAutoClose = isClosingTag;
        if (shouldRewindToAutoClose) {
            shouldRewindToAutoClose = !hasTerminalParent(tagName, stack);
        }
        if (shouldRewindToAutoClose) {
            let currentIndex = stack.length - 1;
            while(currentIndex > 0){
                if (tagName === stack[currentIndex].tagName) {
                    stack.splice(currentIndex);
                    const previousIndex = currentIndex - 1;
                    nodes = stack[previousIndex].children;
                    break;
                }
                currentIndex = currentIndex - 1;
            }
        }
        const attributes = [];
        let attrToken;
        while(cursor < len){
            attrToken = tokens[cursor];
            if (attrToken.type === "tag-end") break;
            attributes.push(attrToken.content);
            cursor++;
        }
        cursor++;
        const children = [];
        const element = {
            type: "element",
            tagName: tagToken.content,
            attributes,
            children
        };
        nodes.push(element);
        const hasChildren = !(attrToken.close || options.html.voidElements.has(tagName));
        if (hasChildren) {
            stack.push({
                tagName,
                children
            });
            const innerState = {
                tokens,
                cursor,
                stack
            };
            parse(innerState);
            cursor = innerState.cursor;
        }
    }
    state.cursor = cursor;
}
function setInnerHTML(element, html) {
    while(element.firstChild){
        element.removeChild(element.firstChild);
    }
    const children = parser(html, element.ownerDocument);
    for(let i = 0; i < children.length; i++){
        element.appendChild(children[i]);
    }
}
function createEvent(event, node) {
    if (typeof event === "string") {
        return new TaroEvent(event, {
            bubbles: true,
            cancelable: true
        });
    }
    const domEv = new TaroEvent(event.type, {
        bubbles: true,
        cancelable: true
    }, event);
    for(const key in event){
        if (key === CURRENT_TARGET || key === TARGET || key === TYPE || key === TIME_STAMP) {
            continue;
        } else {
            domEv[key] = event[key];
        }
    }
    if (domEv.type === CONFIRM && (node === null || node === void 0 ? void 0 : node.nodeName) === INPUT) {
        domEv[KEY_CODE] = 13;
    }
    return domEv;
}
function eventHandler(event) {
    var _a;
    hooks.call("modifyMpEventImpl", event);
    event.currentTarget || (event.currentTarget = event.target);
    const currentTarget = event.currentTarget;
    const id = ((_a = currentTarget.dataset) === null || _a === void 0 ? void 0 : _a.sid) || currentTarget.id || "";
    const node = env.document.getElementById(id);
    if (node) {
        const dispatch = ()=>{
            const e = createEvent(event, node);
            hooks.call("modifyTaroEvent", e, node);
            node.dispatchEvent(e);
        };
        if (hooks.isExist("batchedEventUpdates")) {
            const type = event.type;
            if (!hooks.call("isBubbleEvents", type) || !isParentBinded(node, type) || type === TOUCHMOVE && !!node.props.catchMove) {
                hooks.call("batchedEventUpdates", ()=>{
                    if (eventsBatch[type]) {
                        eventsBatch[type].forEach((fn)=>fn());
                        delete eventsBatch[type];
                    }
                    dispatch();
                });
            } else {
                (eventsBatch[type] || (eventsBatch[type] = [])).push(dispatch);
            }
        } else {
            dispatch();
        }
    }
}
function findCustomWrapper(root, dataPathArr) {
    const list = dataPathArr.slice(1);
    let currentData = root;
    let customWrapper;
    let splitedPath = "";
    list.some((item, i)=>{
        const key = item.replace(/^\[(.+)\]$/, "$1").replace(/\bcn\b/g, "childNodes");
        currentData = currentData[key];
        if (isUndefined(currentData)) return true;
        if (currentData.nodeName === CUSTOM_WRAPPER) {
            const res = customWrapperCache.get(currentData.sid);
            if (res) {
                customWrapper = res;
                splitedPath = dataPathArr.slice(i + 2).join(".");
            }
        }
    });
    if (customWrapper) {
        return {
            customWrapper,
            splitedPath
        };
    }
}
function getComputedStyle(element) {
    return element.style;
}
function injectPageInstance(inst, id) {
    hooks.call("mergePageInstance", instances.get(id), inst);
    instances.set(id, inst);
}
function getPageInstance(id) {
    return instances.get(id);
}
function removePageInstance(id) {
    instances.delete(id);
}
function addLeadingSlash(path) {
    if (path == null) {
        return "";
    }
    return path.charAt(0) === "/" ? path : "/" + path;
}
function safeExecute(path, lifecycle, ...args) {
    const instance = instances.get(path);
    if (instance == null) {
        return;
    }
    const func = hooks.call("getLifecycle", instance, lifecycle);
    if (isArray(func)) {
        const res = func.map((fn)=>fn.apply(instance, args));
        return res[0];
    }
    if (!isFunction(func)) {
        return;
    }
    return func.apply(instance, args);
}
function stringify(obj) {
    if (obj == null) {
        return "";
    }
    const path = Object.keys(obj).map((key)=>{
        return key + "=" + obj[key];
    }).join("&");
    return path === "" ? path : "?" + path;
}
function getPath(id, options2) {
    const idx = id.indexOf("?");
    if (false) {
        return `${idx > -1 ? id.substring(0, idx) : id}${stringify((options2 === null || options2 === void 0 ? void 0 : options2.stamp) ? {
            stamp: options2.stamp
        } : {})}`;
    } else {
        return `${idx > -1 ? id.substring(0, idx) : id}${stringify(options2)}`;
    }
}
function getOnReadyEventKey(path) {
    return path + "." + ON_READY;
}
function getOnShowEventKey(path) {
    return path + "." + ON_SHOW;
}
function getOnHideEventKey(path) {
    return path + "." + ON_HIDE;
}
function createPageConfig(component, pageName, data, pageConfig) {
    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${pageId()}`;
    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES] = hooks.call("getMiniLifecycleImpl").page;
    let pageElement = null;
    let unmounting = false;
    let prepareMountList = [];
    function setCurrentRouter(page) {
        const router = false ? page.$taroPath : page.route || page.__route__ || page.$taroPath;
        Current.router = {
            params: page.$taroParams,
            path: addLeadingSlash(router),
            $taroPath: page.$taroPath,
            onReady: getOnReadyEventKey(id),
            onShow: getOnShowEventKey(id),
            onHide: getOnHideEventKey(id)
        };
        if (!isUndefined(page.exitState)) {
            Current.router.exitState = page.exitState;
        }
    }
    let loadResolver;
    let hasLoaded;
    const config = {
        [ONLOAD] (options2 = {}, cb) {
            hasLoaded = new Promise((resolve)=>{
                loadResolver = resolve;
            });
            perf.start(PAGE_INIT);
            Current.page = this;
            this.config = pageConfig || {};
            const uniqueOptions = Object.assign({}, options2, {
                $taroTimestamp: Date.now()
            });
            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);
            if (false) {
                config.path = $taroPath;
            }
            if (this.$taroParams == null) {
                this.$taroParams = uniqueOptions;
            }
            setCurrentRouter(this);
            const mount = ()=>{
                Current.app.mount(component, $taroPath, ()=>{
                    pageElement = env.document.getElementById($taroPath);
                    ensure(pageElement !== null, "\u6CA1\u6709\u627E\u5230\u9875\u9762\u5B9E\u4F8B\u3002");
                    safeExecute($taroPath, ON_LOAD, this.$taroParams);
                    loadResolver();
                    if (true) {
                        pageElement.ctx = this;
                        pageElement.performUpdate(true, cb);
                    } else {
                        isFunction(cb) && cb();
                    }
                });
            };
            if (unmounting) {
                prepareMountList.push(mount);
            } else {
                mount();
            }
        },
        [ONUNLOAD] () {
            const $taroPath = this.$taroPath;
            safeExecute($taroPath, ONUNLOAD);
            unmounting = true;
            Current.app.unmount($taroPath, ()=>{
                unmounting = false;
                instances.delete($taroPath);
                if (pageElement) {
                    pageElement.ctx = null;
                    pageElement = null;
                }
                if (prepareMountList.length) {
                    prepareMountList.forEach((fn)=>fn());
                    prepareMountList = [];
                }
            });
        },
        [ONREADY] () {
            safeExecute(this.$taroPath, ON_READY);
            _raf(()=>eventCenter.trigger(getOnReadyEventKey(id)));
            this.onReady.called = true;
        },
        [ONSHOW] (options2 = {}) {
            hasLoaded.then(()=>{
                Current.page = this;
                setCurrentRouter(this);
                safeExecute(this.$taroPath, ON_SHOW, options2);
                _raf(()=>eventCenter.trigger(getOnShowEventKey(id)));
            });
        },
        [ONHIDE] () {
            if (Current.page === this) {
                Current.page = null;
                Current.router = null;
            }
            safeExecute(this.$taroPath, ON_HIDE);
            eventCenter.trigger(getOnHideEventKey(id));
        }
    };
    LIFECYCLES.forEach((lifecycle)=>{
        config[lifecycle] = function() {
            return safeExecute(this.$taroPath, lifecycle, ...arguments);
        };
    });
    SIDE_EFFECT_LIFECYCLES.forEach((lifecycle)=>{
        var _a;
        if (component[lifecycle] || ((_a = component.prototype) === null || _a === void 0 ? void 0 : _a[lifecycle]) || component[lifecycle.replace(/^on/, "enable")]) {
            config[lifecycle] = function(...args) {
                var _a2;
                const target = (_a2 = args[0]) === null || _a2 === void 0 ? void 0 : _a2.target;
                if (target === null || target === void 0 ? void 0 : target.id) {
                    const id2 = target.id;
                    const element = env.document.getElementById(id2);
                    if (element) {
                        target.dataset = element.dataset;
                    }
                }
                return safeExecute(this.$taroPath, lifecycle, ...args);
            };
        }
    });
    config.eh = eventHandler;
    if (!isUndefined(data)) {
        config.data = data;
    }
    hooks.call("modifyPageObject", config);
    return config;
}
function createComponentConfig(component, componentName, data) {
    const id = componentName !== null && componentName !== void 0 ? componentName : `taro_component_${pageId()}`;
    let componentElement = null;
    const [ATTACHED, DETACHED] = hooks.call("getMiniLifecycleImpl").component;
    const config = {
        [ATTACHED] () {
            var _a;
            perf.start(PAGE_INIT);
            const path = getPath(id, {
                id: ((_a = this.getPageId) === null || _a === void 0 ? void 0 : _a.call(this)) || pageId()
            });
            Current.app.mount(component, path, ()=>{
                componentElement = env.document.getElementById(path);
                ensure(componentElement !== null, "\u6CA1\u6709\u627E\u5230\u7EC4\u4EF6\u5B9E\u4F8B\u3002");
                this.$taroInstances = instances.get(path);
                safeExecute(path, ON_LOAD);
                if (true) {
                    componentElement.ctx = this;
                    componentElement.performUpdate(true);
                }
            });
        },
        [DETACHED] () {
            const path = getPath(id, {
                id: this.getPageId()
            });
            Current.app.unmount(path, ()=>{
                instances.delete(path);
                if (componentElement) {
                    componentElement.ctx = null;
                }
            });
        },
        methods: {
            eh: eventHandler
        }
    };
    if (!isUndefined(data)) {
        config.data = data;
    }
    [
        OPTIONS,
        EXTERNAL_CLASSES,
        BEHAVIORS
    ].forEach((key)=>{
        var _a;
        config[key] = (_a = component[key]) !== null && _a !== void 0 ? _a : EMPTY_OBJ;
    });
    return config;
}
function createRecursiveComponentConfig(componentName) {
    const isCustomWrapper = componentName === CUSTOM_WRAPPER;
    const [ATTACHED, DETACHED] = hooks.call("getMiniLifecycleImpl").component;
    const lifeCycles = isCustomWrapper ? {
        [ATTACHED] () {
            var _a, _b;
            const componentId = ((_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);
            if (isString(componentId)) {
                customWrapperCache.set(componentId, this);
            }
        },
        [DETACHED] () {
            var _a, _b;
            const componentId = ((_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);
            if (isString(componentId)) {
                customWrapperCache.delete(componentId);
            }
        }
    } : EMPTY_OBJ;
    return Object.assign({
        properties: {
            i: {
                type: Object,
                value: {
                    ["nn"]: getComponentsAlias2()[VIEW]._num
                }
            },
            l: {
                type: String,
                value: ""
            }
        },
        options: {
            addGlobalClass: true,
            virtualHost: !isCustomWrapper
        },
        methods: {
            eh: eventHandler
        }
    }, lifeCycles);
}
var PROPERTY_THRESHOLD, SET_DATA, PAGE_INIT, ROOT_STR, HTML, HEAD, BODY, APP, CONTAINER, DOCUMENT_ELEMENT_NAME, DOCUMENT_FRAGMENT, ID, UID, CLASS, STYLE, FOCUS, VIEW, STATIC_VIEW, PURE_VIEW, VALUE, INPUT, CHANGE, CUSTOM_WRAPPER, TARGET, CURRENT_TARGET, TYPE, CONFIRM, TIME_STAMP, KEY_CODE, TOUCHMOVE, CATCHMOVE, CATCH_VIEW, COMMENT, ON_LOAD, ON_READY, ON_SHOW, ON_HIDE, OPTIONS, EXTERNAL_CLASSES, BEHAVIORS, observers, sidMatches, isConcerned, pendingMuatations, MutationObserver, incrementId, customWrapperCache, componentsAlias$1, ClassList, EventSource, eventSource, env, SPECIAL_NODES, componentsAlias, TaroEventTarget, CHILDNODES, nodeId, TaroNode, WEBKIT, styleProperties, color, style, width, image, size, color_style_width, fitlength_fitwidth_image, fitlength_fitwidth_image_radius, color_style_width_fitlength_fitwidth_image, endRadius_startRadius, bottom_left_right_top, end_start, content_items_self, blockSize_height_inlineSize_width, after_before, Style, TaroElement, options, whitespace, equalSign, alphanumeric, Scaner, LEFT_BRACKET, RIGHT_BRACKET, CLASS_SELECTOR, ID_SELECTOR, CHILD_COMBINATOR, GENERAL_SIBLING_COMBINATOR, ADJACENT_SIBLING_COMBINATOR, StyleTagParser, specialMiniElements, internalCompsList, isMiniElements, isInlineElements, isBlockElements, closingTagAncestorBreakers, TaroEvent, eventsBatch, FormElement, Performance, perf, TaroRootElement, TaroText, TaroDocument, document$1, machine, arch, engine, msg, nav, now, lastTime, _raf, _caf, eventCenter, window$1, SVGElement, Current, getCurrentInstance, instances, pageId, nextTick;
var init_runtime_esm = __esm({
    "node_modules/@tarojs/runtime/dist/runtime.esm.js" () {
        init_shared_esm();
        init_shared_esm();
        PROPERTY_THRESHOLD = 2046;
        SET_DATA = "\u5C0F\u7A0B\u5E8F setData";
        PAGE_INIT = "\u9875\u9762\u521D\u59CB\u5316";
        ROOT_STR = "root";
        HTML = "html";
        HEAD = "head";
        BODY = "body";
        APP = "app";
        CONTAINER = "container";
        DOCUMENT_ELEMENT_NAME = "#document";
        DOCUMENT_FRAGMENT = "document-fragment";
        ID = "id";
        UID = "uid";
        CLASS = "class";
        STYLE = "style";
        FOCUS = "focus";
        VIEW = "view";
        STATIC_VIEW = "static-view";
        PURE_VIEW = "pure-view";
        VALUE = "value";
        INPUT = "input";
        CHANGE = "change";
        CUSTOM_WRAPPER = "custom-wrapper";
        TARGET = "target";
        CURRENT_TARGET = "currentTarget";
        TYPE = "type";
        CONFIRM = "confirm";
        TIME_STAMP = "timeStamp";
        KEY_CODE = "keyCode";
        TOUCHMOVE = "touchmove";
        CATCHMOVE = "catchMove";
        CATCH_VIEW = "catch-view";
        COMMENT = "comment";
        ON_LOAD = "onLoad";
        ON_READY = "onReady";
        ON_SHOW = "onShow";
        ON_HIDE = "onHide";
        OPTIONS = "options";
        EXTERNAL_CLASSES = "externalClasses";
        BEHAVIORS = "behaviors";
        observers = [];
        sidMatches = (observerTarget, target)=>{
            return !!observerTarget && observerTarget.sid === (target === null || target === void 0 ? void 0 : target.sid);
        };
        isConcerned = (record, options2)=>{
            const { characterData , characterDataOldValue , attributes , attributeOldValue , childList  } = options2;
            switch(record.type){
                case "characterData":
                    if (characterData) {
                        if (!characterDataOldValue) record.oldValue = null;
                        return true;
                    }
                    return false;
                case "attributes":
                    if (attributes) {
                        if (!attributeOldValue) record.oldValue = null;
                        return true;
                    }
                    return false;
                case "childList":
                    if (childList) {
                        return true;
                    }
                    return false;
            }
        };
        pendingMuatations = false;
        MutationObserver = class {
            observe(...args) {
                this.core.observe(...args);
            }
            disconnect() {
                this.core.disconnect();
            }
            takeRecords() {
                return this.core.takeRecords();
            }
            static record(record) {
                recordMutation(record);
            }
            constructor(callback){
                if (false) {
                    this.core = new MutationObserverImpl(callback);
                } else {
                    if (true) {
                        console.warn("[Taro Warning] \u82E5\u8981\u4F7F\u7528 MutationObserver\uFF0C\u8BF7\u5728 Taro \u7F16\u8BD1\u914D\u7F6E\u4E2D\u8BBE\u7F6E 'mini.enableMutationObserver: true'");
                    }
                    this.core = {
                        observe: noop,
                        disconnect: noop,
                        takeRecords: noop
                    };
                }
            }
        };
        incrementId = ()=>{
            const chatCodes = [];
            for(let i = 65; i <= 90; i++){
                chatCodes.push(i);
            }
            for(let i1 = 97; i1 <= 122; i1++){
                chatCodes.push(i1);
            }
            const chatCodesLen = chatCodes.length - 1;
            const list = [
                0,
                0
            ];
            return ()=>{
                const target = list.map((item)=>chatCodes[item]);
                const res = String.fromCharCode(...target);
                let tailIdx = list.length - 1;
                list[tailIdx]++;
                while(list[tailIdx] > chatCodesLen){
                    list[tailIdx] = 0;
                    tailIdx = tailIdx - 1;
                    if (tailIdx < 0) {
                        list.push(0);
                        break;
                    }
                    list[tailIdx]++;
                }
                return res;
            };
        };
        customWrapperCache = /* @__PURE__ */ new Map();
        ClassList = class extends Set {
            get value() {
                return [
                    ...this
                ].filter((v)=>v !== "").join(" ");
            }
            add(s) {
                super.add(s);
                this._update();
                return this;
            }
            get length() {
                return this.size;
            }
            remove(s) {
                super.delete(s);
                this._update();
            }
            toggle(s) {
                if (super.has(s)) {
                    super.delete(s);
                } else {
                    super.add(s);
                }
                this._update();
            }
            replace(s1, s2) {
                super.delete(s1);
                super.add(s2);
                this._update();
            }
            contains(s) {
                return super.has(s);
            }
            toString() {
                return this.value;
            }
            _update() {
                this.el.className = this.value;
            }
            constructor(className, el){
                super();
                className.trim().split(/\s+/).forEach(super.add.bind(this));
                this.el = el;
            }
        };
        EventSource = class extends Map {
            removeNode(child) {
                const { sid , uid  } = child;
                this.delete(sid);
                if (uid !== sid && uid) this.delete(uid);
            }
            removeNodeTree(child) {
                this.removeNode(child);
                const { childNodes  } = child;
                childNodes.forEach((node)=>this.removeNodeTree(node));
            }
        };
        eventSource = new EventSource();
        env = {
            window: false ? window : EMPTY_OBJ,
            document: false ? document : EMPTY_OBJ
        };
        TaroEventTarget = class {
            addEventListener(type, handler, options2) {
                type = type.toLowerCase();
                hooks.call("onAddEvent", type, handler, options2, this);
                if (type === "regionchange") {
                    this.addEventListener("begin", handler, options2);
                    this.addEventListener("end", handler, options2);
                    return;
                }
                let isCapture = Boolean(options2);
                let isOnce = false;
                if (isObject(options2)) {
                    isCapture = Boolean(options2.capture);
                    isOnce = Boolean(options2.once);
                }
                if (isOnce) {
                    const wrapper = function() {
                        handler.apply(this, arguments);
                        this.removeEventListener(type, wrapper);
                    };
                    this.addEventListener(type, wrapper, Object.assign(Object.assign({}, options2), {
                        once: false
                    }));
                    return;
                }
                warn(isCapture, "Taro \u6682\u672A\u5B9E\u73B0 event \u7684 capture \u7279\u6027\u3002");
                const oldHandler = handler;
                handler = function() {
                    oldHandler.apply(this, arguments);
                };
                handler.oldHandler = oldHandler;
                const handlers = this.__handlers[type];
                if (isArray(handlers)) {
                    handlers.push(handler);
                } else {
                    this.__handlers[type] = [
                        handler
                    ];
                }
            }
            removeEventListener(type, handler) {
                type = type.toLowerCase();
                if (type === "regionchange") {
                    this.removeEventListener("begin", handler);
                    this.removeEventListener("end", handler);
                    return;
                }
                if (!handler) {
                    return;
                }
                const handlers = this.__handlers[type];
                if (!isArray(handlers)) {
                    return;
                }
                const index = handlers.findIndex((item)=>{
                    if (item === handler || item.oldHandler === handler) return true;
                });
                warn(index === -1, `\u4E8B\u4EF6: '${type}' \u6CA1\u6709\u6CE8\u518C\u5728 DOM \u4E2D\uFF0C\u56E0\u6B64\u4E0D\u4F1A\u88AB\u79FB\u9664\u3002`);
                handlers.splice(index, 1);
            }
            isAnyEventBinded() {
                const handlers = this.__handlers;
                const isAnyEventBinded = Object.keys(handlers).find((key)=>handlers[key].length);
                return Boolean(isAnyEventBinded);
            }
            constructor(){
                this.__handlers = {};
            }
        };
        CHILDNODES = "cn";
        nodeId = incrementId();
        TaroNode = class extends TaroEventTarget {
            updateChildNodes(isClean) {
                const cleanChildNodes = ()=>[];
                const rerenderChildNodes = ()=>{
                    const childNodes = this.childNodes.filter((node)=>!isComment(node));
                    return childNodes.map(hydrate);
                };
                this.enqueueUpdate({
                    path: `${this._path}.${CHILDNODES}`,
                    value: isClean ? cleanChildNodes : rerenderChildNodes
                });
            }
            get _root() {
                var _a;
                return ((_a = this.parentNode) === null || _a === void 0 ? void 0 : _a._root) || null;
            }
            findIndex(refChild) {
                const index = this.childNodes.indexOf(refChild);
                ensure(index !== -1, "The node to be replaced is not a child of this node.");
                return index;
            }
            get _path() {
                const parentNode = this.parentNode;
                if (parentNode) {
                    const list = parentNode.childNodes.filter((node)=>!isComment(node));
                    const indexOfNode = list.indexOf(this);
                    const index = hooks.call("getPathIndex", indexOfNode);
                    return `${parentNode._path}.${CHILDNODES}.${index}`;
                }
                return "";
            }
            get nextSibling() {
                const parentNode = this.parentNode;
                return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) + 1]) || null;
            }
            get previousSibling() {
                const parentNode = this.parentNode;
                return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) - 1]) || null;
            }
            get parentElement() {
                const parentNode = this.parentNode;
                if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 1) {
                    return parentNode;
                }
                return null;
            }
            get firstChild() {
                return this.childNodes[0] || null;
            }
            get lastChild() {
                const childNodes = this.childNodes;
                return childNodes[childNodes.length - 1] || null;
            }
            set textContent(text) {
                const removedNodes = this.childNodes.slice();
                const addedNodes = [];
                while(this.firstChild){
                    this.removeChild(this.firstChild, {
                        doUpdate: false
                    });
                }
                if (text === "") {
                    this.updateChildNodes(true);
                } else {
                    const newText = env.document.createTextNode(text);
                    addedNodes.push(newText);
                    this.appendChild(newText);
                    this.updateChildNodes();
                }
                MutationObserver.record({
                    type: "childList",
                    target: this,
                    removedNodes,
                    addedNodes
                });
            }
            insertBefore(newChild, refChild, isReplace) {
                if (newChild.nodeName === DOCUMENT_FRAGMENT) {
                    newChild.childNodes.reduceRight((previousValue, currentValue)=>{
                        this.insertBefore(currentValue, previousValue);
                        return currentValue;
                    }, refChild);
                    return newChild;
                }
                newChild.remove({
                    cleanRef: false
                });
                newChild.parentNode = this;
                if (refChild) {
                    const index = this.findIndex(refChild);
                    this.childNodes.splice(index, 0, newChild);
                } else {
                    this.childNodes.push(newChild);
                }
                if (this._root) {
                    if (!refChild) {
                        const isOnlyChild = this.childNodes.length === 1;
                        if (isOnlyChild) {
                            this.updateChildNodes();
                        } else {
                            this.enqueueUpdate({
                                path: newChild._path,
                                value: this.hydrate(newChild)
                            });
                        }
                    } else if (isReplace) {
                        this.enqueueUpdate({
                            path: newChild._path,
                            value: this.hydrate(newChild)
                        });
                    } else {
                        this.updateChildNodes();
                    }
                }
                MutationObserver.record({
                    type: "childList",
                    target: this,
                    addedNodes: [
                        newChild
                    ],
                    removedNodes: isReplace ? [
                        refChild
                    ] : [],
                    nextSibling: isReplace ? refChild.nextSibling : refChild || null,
                    previousSibling: newChild.previousSibling
                });
                return newChild;
            }
            appendChild(newChild) {
                return this.insertBefore(newChild);
            }
            replaceChild(newChild, oldChild) {
                if (oldChild.parentNode !== this) return;
                this.insertBefore(newChild, oldChild, true);
                oldChild.remove({
                    doUpdate: false
                });
                return oldChild;
            }
            removeChild(child, options2 = {}) {
                const { cleanRef , doUpdate  } = options2;
                if (cleanRef !== false && doUpdate !== false) {
                    MutationObserver.record({
                        type: "childList",
                        target: this,
                        removedNodes: [
                            child
                        ],
                        nextSibling: child.nextSibling,
                        previousSibling: child.previousSibling
                    });
                }
                const index = this.findIndex(child);
                this.childNodes.splice(index, 1);
                child.parentNode = null;
                if (cleanRef !== false) {
                    eventSource.removeNodeTree(child);
                }
                if (this._root && doUpdate !== false) {
                    this.updateChildNodes();
                }
                return child;
            }
            remove(options2) {
                var _a;
                (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this, options2);
            }
            hasChildNodes() {
                return this.childNodes.length > 0;
            }
            enqueueUpdate(payload) {
                var _a;
                (_a = this._root) === null || _a === void 0 ? void 0 : _a.enqueueUpdate(payload);
            }
            get ownerDocument() {
                return env.document;
            }
            static extend(methodName, options2) {
                extend(TaroNode, methodName, options2);
            }
            constructor(){
                super();
                this.parentNode = null;
                this.childNodes = [];
                this.hydrate = (node)=>()=>hydrate(node);
                this.uid = "_" + nodeId();
                this.sid = this.uid;
                eventSource.set(this.sid, this);
            }
        };
        WEBKIT = "webkit";
        styleProperties = [
            "all",
            "appearance",
            "blockOverflow",
            "blockSize",
            "bottom",
            "clear",
            "contain",
            "content",
            "continue",
            "cursor",
            "direction",
            "display",
            "filter",
            "float",
            "gap",
            "height",
            "inset",
            "isolation",
            "left",
            "letterSpacing",
            "lightingColor",
            "markerSide",
            "mixBlendMode",
            "opacity",
            "order",
            "position",
            "quotes",
            "resize",
            "right",
            "rowGap",
            "tabSize",
            "tableLayout",
            "top",
            "userSelect",
            "verticalAlign",
            "visibility",
            "voiceFamily",
            "volume",
            "whiteSpace",
            "widows",
            "width",
            "zIndex",
            "pointerEvents"
        ];
        color = "Color";
        style = "Style";
        width = "Width";
        image = "Image";
        size = "Size";
        color_style_width = [
            color,
            style,
            width
        ];
        fitlength_fitwidth_image = [
            "FitLength",
            "FitWidth",
            image
        ];
        fitlength_fitwidth_image_radius = [
            ...fitlength_fitwidth_image,
            "Radius"
        ];
        color_style_width_fitlength_fitwidth_image = [
            ...color_style_width,
            ...fitlength_fitwidth_image
        ];
        endRadius_startRadius = [
            "EndRadius",
            "StartRadius"
        ];
        bottom_left_right_top = [
            "Bottom",
            "Left",
            "Right",
            "Top"
        ];
        end_start = [
            "End",
            "Start"
        ];
        content_items_self = [
            "Content",
            "Items",
            "Self"
        ];
        blockSize_height_inlineSize_width = [
            "BlockSize",
            "Height",
            "InlineSize",
            width
        ];
        after_before = [
            "After",
            "Before"
        ];
        combine("borderBlock", color_style_width);
        combine("borderBlockEnd", color_style_width);
        combine("borderBlockStart", color_style_width);
        combine("outline", [
            ...color_style_width,
            "Offset"
        ]);
        combine("border", [
            ...color_style_width,
            "Boundary",
            "Break",
            "Collapse",
            "Radius",
            "Spacing"
        ]);
        combine("borderFit", [
            "Length",
            width
        ]);
        combine("borderInline", color_style_width);
        combine("borderInlineEnd", color_style_width);
        combine("borderInlineStart", color_style_width);
        combine("borderLeft", color_style_width_fitlength_fitwidth_image);
        combine("borderRight", color_style_width_fitlength_fitwidth_image);
        combine("borderTop", color_style_width_fitlength_fitwidth_image);
        combine("borderBottom", color_style_width_fitlength_fitwidth_image);
        combine("textDecoration", [
            color,
            style,
            "Line"
        ]);
        combine("textEmphasis", [
            color,
            style,
            "Position"
        ]);
        combine("scrollMargin", bottom_left_right_top);
        combine("scrollPadding", bottom_left_right_top);
        combine("padding", bottom_left_right_top);
        combine("margin", [
            ...bottom_left_right_top,
            "Trim"
        ]);
        combine("scrollMarginBlock", end_start);
        combine("scrollMarginInline", end_start);
        combine("scrollPaddingBlock", end_start);
        combine("scrollPaddingInline", end_start);
        combine("gridColumn", end_start);
        combine("gridRow", end_start);
        combine("insetBlock", end_start);
        combine("insetInline", end_start);
        combine("marginBlock", end_start);
        combine("marginInline", end_start);
        combine("paddingBlock", end_start);
        combine("paddingInline", end_start);
        combine("pause", after_before);
        combine("cue", after_before);
        combine("mask", [
            "Clip",
            "Composite",
            image,
            "Mode",
            "Origin",
            "Position",
            "Repeat",
            size,
            "Type"
        ]);
        combine("borderImage", [
            "Outset",
            "Repeat",
            "Slice",
            "Source",
            "Transform",
            width
        ]);
        combine("maskBorder", [
            "Mode",
            "Outset",
            "Repeat",
            "Slice",
            "Source",
            width
        ]);
        combine("font", [
            "Family",
            "FeatureSettings",
            "Kerning",
            "LanguageOverride",
            "MaxSize",
            "MinSize",
            "OpticalSizing",
            "Palette",
            size,
            "SizeAdjust",
            "Stretch",
            style,
            "Weight",
            "VariationSettings"
        ]);
        combine("transform", [
            "Box",
            "Origin",
            style
        ]);
        combine("background", [
            color,
            image,
            "Attachment",
            "BlendMode",
            "Clip",
            "Origin",
            "Position",
            "Repeat",
            size
        ]);
        combine("listStyle", [
            image,
            "Position",
            "Type"
        ]);
        combine("scrollSnap", [
            "Align",
            "Stop",
            "Type"
        ]);
        combine("grid", [
            "Area",
            "AutoColumns",
            "AutoFlow",
            "AutoRows"
        ]);
        combine("gridTemplate", [
            "Areas",
            "Columns",
            "Rows"
        ]);
        combine("overflow", [
            "Block",
            "Inline",
            "Wrap",
            "X",
            "Y"
        ]);
        combine("transition", [
            "Delay",
            "Duration",
            "Property",
            "TimingFunction"
        ]);
        combine("color", [
            "Adjust",
            "InterpolationFilters",
            "Scheme"
        ]);
        combine("textAlign", [
            "All",
            "Last"
        ]);
        combine("page", [
            "BreakAfter",
            "BreakBefore",
            "BreakInside"
        ]);
        combine("animation", [
            "Delay",
            "Direction",
            "Duration",
            "FillMode",
            "IterationCount",
            "Name",
            "PlayState",
            "TimingFunction"
        ]);
        combine("flex", [
            "Basis",
            "Direction",
            "Flow",
            "Grow",
            "Shrink",
            "Wrap"
        ]);
        combine("offset", [
            ...after_before,
            ...end_start,
            "Anchor",
            "Distance",
            "Path",
            "Position",
            "Rotate"
        ]);
        combine("perspective", [
            "Origin"
        ]);
        combine("clip", [
            "Path",
            "Rule"
        ]);
        combine("flow", [
            "From",
            "Into"
        ]);
        combine("align", [
            "Content",
            "Items",
            "Self"
        ], true);
        combine("alignment", [
            "Adjust",
            "Baseline"
        ], true);
        combine("borderStart", endRadius_startRadius, true);
        combine("borderEnd", endRadius_startRadius, true);
        combine("borderCorner", [
            "Fit",
            image,
            "ImageTransform"
        ], true);
        combine("borderTopLeft", fitlength_fitwidth_image_radius, true);
        combine("borderTopRight", fitlength_fitwidth_image_radius, true);
        combine("borderBottomLeft", fitlength_fitwidth_image_radius, true);
        combine("borderBottomRight", fitlength_fitwidth_image_radius, true);
        combine("column", [
            "s",
            "Count",
            "Fill",
            "Gap",
            "Rule",
            "RuleColor",
            "RuleStyle",
            "RuleWidth",
            "Span",
            width
        ], true);
        combine("break", [
            ...after_before,
            "Inside"
        ], true);
        combine("wrap", [
            ...after_before,
            "Flow",
            "Inside",
            "Through"
        ], true);
        combine("justify", content_items_self, true);
        combine("place", content_items_self, true);
        combine("max", [
            ...blockSize_height_inlineSize_width,
            "Lines"
        ], true);
        combine("min", blockSize_height_inlineSize_width, true);
        combine("line", [
            "Break",
            "Clamp",
            "Grid",
            "Height",
            "Padding",
            "Snap"
        ], true);
        combine("inline", [
            "BoxAlign",
            size,
            "Sizing"
        ], true);
        combine("text", [
            "CombineUpright",
            "GroupAlign",
            "Height",
            "Indent",
            "Justify",
            "Orientation",
            "Overflow",
            "Shadow",
            "SpaceCollapse",
            "SpaceTrim",
            "Spacing",
            "Transform",
            "UnderlinePosition",
            "Wrap"
        ], true);
        combine("shape", [
            "ImageThreshold",
            "Inside",
            "Margin",
            "Outside"
        ], true);
        combine("word", [
            "Break",
            "Spacing",
            "Wrap"
        ], true);
        combine("object", [
            "Fit",
            "Position"
        ], true);
        combine("box", [
            "DecorationBreak",
            "Shadow",
            "Sizing",
            "Snap"
        ], true);
        combine(WEBKIT, [
            "LineClamp",
            "BoxOrient",
            "TextFillColor",
            "TextStroke",
            "TextStrokeColor",
            "TextStrokeWidth"
        ], true);
        Style = class {
            setCssVariables(styleKey) {
                this.hasOwnProperty(styleKey) || Object.defineProperty(this, styleKey, {
                    enumerable: true,
                    configurable: true,
                    get: ()=>{
                        return this._value[styleKey] || "";
                    },
                    set: (newVal)=>{
                        setStyle.call(this, newVal, styleKey);
                    }
                });
            }
            get cssText() {
                if (!this._usedStyleProp.size) return "";
                const texts = [];
                this._usedStyleProp.forEach((key)=>{
                    const val = this[key];
                    if (isNull(val) || isUndefined(val)) return;
                    let styleName = isCssVariable(key) ? key : toDashed(key);
                    if (styleName.indexOf("webkit") === 0 || styleName.indexOf("Webkit") === 0) {
                        styleName = `-${styleName}`;
                    }
                    texts.push(`${styleName}: ${val};`);
                });
                return texts.join(" ");
            }
            set cssText(str) {
                this._pending = true;
                recordCss(this);
                this._usedStyleProp.forEach((prop)=>{
                    this.removeProperty(prop);
                });
                if (str === "" || isUndefined(str) || isNull(str)) {
                    this._pending = false;
                    enqueueUpdate(this);
                    return;
                }
                const rules = str.split(";");
                for(let i = 0; i < rules.length; i++){
                    const rule = rules[i].trim();
                    if (rule === "") {
                        continue;
                    }
                    const [propName, ...valList] = rule.split(":");
                    const val = valList.join(":");
                    if (isUndefined(val)) {
                        continue;
                    }
                    this.setProperty(propName.trim(), val.trim());
                }
                this._pending = false;
                enqueueUpdate(this);
            }
            setProperty(propertyName, value) {
                if (propertyName[0] === "-") {
                    this.setCssVariables(propertyName);
                } else {
                    propertyName = toCamelCase(propertyName);
                }
                if (isNull(value) || isUndefined(value)) {
                    this.removeProperty(propertyName);
                } else {
                    this[propertyName] = value;
                }
            }
            removeProperty(propertyName) {
                propertyName = toCamelCase(propertyName);
                if (!this._usedStyleProp.has(propertyName)) {
                    return "";
                }
                const value = this[propertyName];
                this[propertyName] = void 0;
                return value;
            }
            getPropertyValue(propertyName) {
                propertyName = toCamelCase(propertyName);
                const value = this[propertyName];
                if (!value) {
                    return "";
                }
                return value;
            }
            constructor(element){
                this._element = element;
                this._usedStyleProp = /* @__PURE__ */ new Set();
                this._value = {};
            }
        };
        initStyle(Style);
        TaroElement = class extends TaroNode {
            _stopPropagation(event) {
                let target = this;
                while(target = target.parentNode){
                    const listeners = target.__handlers[event.type];
                    if (!isArray(listeners)) {
                        continue;
                    }
                    for(let i = listeners.length; i--;){
                        const l = listeners[i];
                        l._stop = true;
                    }
                }
            }
            get id() {
                return this.getAttribute(ID);
            }
            set id(val) {
                this.setAttribute(ID, val);
            }
            get className() {
                return this.getAttribute(CLASS) || "";
            }
            set className(val) {
                this.setAttribute(CLASS, val);
            }
            get cssText() {
                return this.getAttribute(STYLE) || "";
            }
            get classList() {
                return new ClassList(this.className, this);
            }
            get children() {
                return this.childNodes.filter(isElement);
            }
            get attributes() {
                const props = this.props;
                const propKeys = Object.keys(props);
                const style2 = this.style.cssText;
                const attrs = propKeys.map((key)=>({
                        name: key,
                        value: props[key]
                    }));
                return attrs.concat(style2 ? {
                    name: STYLE,
                    value: style2
                } : []);
            }
            get textContent() {
                let text = "";
                const childNodes = this.childNodes;
                for(let i = 0; i < childNodes.length; i++){
                    text += childNodes[i].textContent;
                }
                return text;
            }
            set textContent(text) {
                super.textContent = text;
            }
            hasAttribute(qualifiedName) {
                return !isUndefined(this.props[qualifiedName]);
            }
            hasAttributes() {
                return this.attributes.length > 0;
            }
            get focus() {
                return function() {
                    this.setAttribute(FOCUS, true);
                };
            }
            set focus(value) {
                this.setAttribute(FOCUS, value);
            }
            blur() {
                this.setAttribute(FOCUS, false);
            }
            setAttribute(qualifiedName, value) {
                warn(isString(value) && value.length > PROPERTY_THRESHOLD, `\u5143\u7D20 ${this.nodeName} \u7684 ${qualifiedName} \u5C5E\u6027\u503C\u6570\u636E\u91CF\u8FC7\u5927\uFF0C\u53EF\u80FD\u4F1A\u5F71\u54CD\u6E32\u67D3\u6027\u80FD\u3002\u8003\u8651\u964D\u4F4E\u56FE\u7247\u8F6C\u4E3A base64 \u7684\u9608\u503C\u6216\u5728 CSS \u4E2D\u4F7F\u7528 base64\u3002`);
                const isPureView = this.nodeName === VIEW && !isHasExtractProp(this) && !this.isAnyEventBinded();
                if (qualifiedName !== STYLE) {
                    MutationObserver.record({
                        target: this,
                        type: "attributes",
                        attributeName: qualifiedName,
                        oldValue: this.getAttribute(qualifiedName)
                    });
                }
                switch(qualifiedName){
                    case STYLE:
                        this.style.cssText = value;
                        break;
                    case ID:
                        if (this.uid !== this.sid) {
                            eventSource.delete(this.uid);
                        }
                        value = String(value);
                        this.props[qualifiedName] = this.uid = value;
                        eventSource.set(value, this);
                        break;
                    default:
                        this.props[qualifiedName] = value;
                        if (qualifiedName.startsWith("data-")) {
                            if (this.dataset === EMPTY_OBJ) {
                                this.dataset = /* @__PURE__ */ Object.create(null);
                            }
                            this.dataset[toCamelCase(qualifiedName.replace(/^data-/, ""))] = value;
                        }
                        break;
                }
                if (!this._root) return;
                const componentsAlias2 = getComponentsAlias2();
                const _alias = componentsAlias2[this.nodeName];
                const viewAlias = componentsAlias2[VIEW]._num;
                const staticViewAlias = componentsAlias2[STATIC_VIEW]._num;
                const catchViewAlias = componentsAlias2[CATCH_VIEW]._num;
                const _path = this._path;
                qualifiedName = shortcutAttr(qualifiedName);
                const qualifiedNameInCamelCase = toCamelCase(qualifiedName);
                const payload = {
                    path: `${_path}.${qualifiedNameInCamelCase}`,
                    value: isFunction(value) ? ()=>value : value
                };
                hooks.call("modifySetAttrPayload", this, qualifiedName, payload, componentsAlias2);
                if (_alias) {
                    const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;
                    payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;
                }
                this.enqueueUpdate(payload);
                if (this.nodeName === VIEW) {
                    if (qualifiedNameInCamelCase === CATCHMOVE) {
                        this.enqueueUpdate({
                            path: `${_path}.${"nn"}`,
                            value: value ? catchViewAlias : this.isAnyEventBinded() ? viewAlias : staticViewAlias
                        });
                    } else if (isPureView && isHasExtractProp(this)) {
                        this.enqueueUpdate({
                            path: `${_path}.${"nn"}`,
                            value: staticViewAlias
                        });
                    }
                }
            }
            removeAttribute(qualifiedName) {
                const isStaticView = this.nodeName === VIEW && isHasExtractProp(this) && !this.isAnyEventBinded();
                MutationObserver.record({
                    target: this,
                    type: "attributes",
                    attributeName: qualifiedName,
                    oldValue: this.getAttribute(qualifiedName)
                });
                if (qualifiedName === STYLE) {
                    this.style.cssText = "";
                } else {
                    const isInterrupt = hooks.call("onRemoveAttribute", this, qualifiedName);
                    if (isInterrupt) {
                        return;
                    }
                    if (!this.props.hasOwnProperty(qualifiedName)) {
                        return;
                    }
                    delete this.props[qualifiedName];
                }
                if (!this._root) return;
                const componentsAlias2 = getComponentsAlias2();
                const _alias = componentsAlias2[this.nodeName];
                const viewAlias = componentsAlias2[VIEW]._num;
                const staticViewAlias = componentsAlias2[STATIC_VIEW]._num;
                const pureViewAlias = componentsAlias2[PURE_VIEW]._num;
                const _path = this._path;
                qualifiedName = shortcutAttr(qualifiedName);
                const qualifiedNameInCamelCase = toCamelCase(qualifiedName);
                const payload = {
                    path: `${_path}.${qualifiedNameInCamelCase}`,
                    value: ""
                };
                hooks.call("modifyRmAttrPayload", this, qualifiedName, payload, componentsAlias2);
                if (_alias) {
                    const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;
                    payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;
                }
                this.enqueueUpdate(payload);
                if (this.nodeName === VIEW) {
                    if (qualifiedNameInCamelCase === CATCHMOVE) {
                        this.enqueueUpdate({
                            path: `${_path}.${"nn"}`,
                            value: this.isAnyEventBinded() ? viewAlias : isHasExtractProp(this) ? staticViewAlias : pureViewAlias
                        });
                    } else if (isStaticView && !isHasExtractProp(this)) {
                        this.enqueueUpdate({
                            path: `${_path}.${"nn"}`,
                            value: pureViewAlias
                        });
                    }
                }
            }
            getAttribute(qualifiedName) {
                const attr = qualifiedName === STYLE ? this.style.cssText : this.props[qualifiedName];
                return attr !== null && attr !== void 0 ? attr : "";
            }
            getElementsByTagName(tagName) {
                return treeToArray(this, (el)=>{
                    return el.nodeName === tagName || tagName === "*" && this !== el;
                });
            }
            getElementsByClassName(className) {
                return treeToArray(this, (el)=>{
                    const classList = el.classList;
                    const classNames = className.trim().split(/\s+/);
                    return classNames.every((c)=>classList.has(c));
                });
            }
            dispatchEvent(event) {
                const cancelable = event.cancelable;
                const listeners = this.__handlers[event.type];
                if (!isArray(listeners)) {
                    return false;
                }
                for(let i = listeners.length; i--;){
                    const listener = listeners[i];
                    let result;
                    if (listener._stop) {
                        listener._stop = false;
                    } else {
                        hooks.call("modifyDispatchEvent", event, this);
                        result = listener.call(this, event);
                    }
                    if ((result === false || event._end) && cancelable) {
                        event.defaultPrevented = true;
                    }
                    if (event._end && event._stop) {
                        break;
                    }
                }
                if (event._stop) {
                    this._stopPropagation(event);
                } else {
                    event._stop = true;
                }
                return listeners != null;
            }
            addEventListener(type, handler, options2) {
                const name = this.nodeName;
                const SPECIAL_NODES2 = hooks.call("getSpecialNodes");
                let sideEffect = true;
                if (isObject(options2) && options2.sideEffect === false) {
                    sideEffect = false;
                    delete options2.sideEffect;
                }
                if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES2.indexOf(name) > -1) {
                    const componentsAlias2 = getComponentsAlias2();
                    const alias = componentsAlias2[name]._num;
                    this.enqueueUpdate({
                        path: `${this._path}.${"nn"}`,
                        value: alias
                    });
                }
                super.addEventListener(type, handler, options2);
            }
            removeEventListener(type, handler, sideEffect = true) {
                super.removeEventListener(type, handler);
                const name = this.nodeName;
                const SPECIAL_NODES2 = hooks.call("getSpecialNodes");
                if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES2.indexOf(name) > -1) {
                    const componentsAlias2 = getComponentsAlias2();
                    const value = isHasExtractProp(this) ? `static-${name}` : `pure-${name}`;
                    const valueAlias = componentsAlias2[value]._num;
                    this.enqueueUpdate({
                        path: `${this._path}.${"nn"}`,
                        value: valueAlias
                    });
                }
            }
            static extend(methodName, options2) {
                extend(TaroElement, methodName, options2);
            }
            constructor(){
                super();
                this.props = {};
                this.dataset = EMPTY_OBJ;
                this.nodeType = 1;
                this.style = new Style(this);
                hooks.call("patchElement", this);
            }
        };
        options = {
            prerender: true,
            debug: false
        };
        whitespace = /\s/;
        equalSign = /=/;
        alphanumeric = /[A-Za-z0-9]/;
        Scaner = class {
            scan() {
                const { html , position  } = this;
                const len = html.length;
                while(position.index < len){
                    const start = position.index;
                    this.scanText();
                    if (position.index === start) {
                        const isComment2 = html.startsWith("!--", start + 1);
                        if (isComment2) {
                            this.scanComment();
                        } else {
                            const tagName = this.scanTag();
                            if (shouldBeIgnore(tagName)) {
                                this.scanSkipTag(tagName);
                            }
                        }
                    }
                }
                return this.tokens;
            }
            scanText() {
                const type = "text";
                const { html , position  } = this;
                let textEnd = findTextEnd(html, position.index);
                if (textEnd === position.index) {
                    return;
                }
                if (textEnd === -1) {
                    textEnd = html.length;
                }
                const start = copyPosition(position);
                const content = html.slice(position.index, textEnd);
                jumpPosition(position, html, textEnd);
                const end = copyPosition(position);
                this.tokens.push({
                    type,
                    content,
                    position: {
                        start,
                        end
                    }
                });
            }
            scanComment() {
                const type = "comment";
                const { html , position  } = this;
                const start = copyPosition(position);
                feedPosition(position, html, 4);
                let contentEnd = html.indexOf("-->", position.index);
                let commentEnd = contentEnd + 3;
                if (contentEnd === -1) {
                    contentEnd = commentEnd = html.length;
                }
                const content = html.slice(position.index, contentEnd);
                jumpPosition(position, html, commentEnd);
                this.tokens.push({
                    type,
                    content,
                    position: {
                        start,
                        end: copyPosition(position)
                    }
                });
            }
            scanTag() {
                this.scanTagStart();
                const tagName = this.scanTagName();
                this.scanAttrs();
                this.scanTagEnd();
                return tagName;
            }
            scanTagStart() {
                const type = "tag-start";
                const { html , position  } = this;
                const secondChar = html.charAt(position.index + 1);
                const close = secondChar === "/";
                const start = copyPosition(position);
                feedPosition(position, html, close ? 2 : 1);
                this.tokens.push({
                    type,
                    close,
                    position: {
                        start
                    }
                });
            }
            scanTagEnd() {
                const type = "tag-end";
                const { html , position  } = this;
                const firstChar = html.charAt(position.index);
                const close = firstChar === "/";
                feedPosition(position, html, close ? 2 : 1);
                const end = copyPosition(position);
                this.tokens.push({
                    type,
                    close,
                    position: {
                        end
                    }
                });
            }
            scanTagName() {
                const type = "tag";
                const { html , position  } = this;
                const len = html.length;
                let start = position.index;
                while(start < len){
                    const char = html.charAt(start);
                    const isTagChar = !(isWhitespaceChar(char) || char === "/" || char === ">");
                    if (isTagChar) break;
                    start++;
                }
                let end = start + 1;
                while(end < len){
                    const char1 = html.charAt(end);
                    const isTagChar1 = !(isWhitespaceChar(char1) || char1 === "/" || char1 === ">");
                    if (!isTagChar1) break;
                    end++;
                }
                jumpPosition(position, html, end);
                const tagName = html.slice(start, end);
                this.tokens.push({
                    type,
                    content: tagName
                });
                return tagName;
            }
            scanAttrs() {
                const { html , position , tokens  } = this;
                let cursor = position.index;
                let quote = null;
                let wordBegin = cursor;
                const words = [];
                const len = html.length;
                while(cursor < len){
                    const char = html.charAt(cursor);
                    if (quote) {
                        const isQuoteEnd = char === quote;
                        if (isQuoteEnd) {
                            quote = null;
                        }
                        cursor++;
                        continue;
                    }
                    const isTagEnd = char === "/" || char === ">";
                    if (isTagEnd) {
                        if (cursor !== wordBegin) {
                            words.push(html.slice(wordBegin, cursor));
                        }
                        break;
                    }
                    if (isWordEnd(cursor, wordBegin, html)) {
                        if (cursor !== wordBegin) {
                            words.push(html.slice(wordBegin, cursor));
                        }
                        wordBegin = cursor + 1;
                        cursor++;
                        continue;
                    }
                    const isQuoteStart = char === "'" || char === '"';
                    if (isQuoteStart) {
                        quote = char;
                        cursor++;
                        continue;
                    }
                    cursor++;
                }
                jumpPosition(position, html, cursor);
                const wLen = words.length;
                const type = "attribute";
                for(let i = 0; i < wLen; i++){
                    const word = words[i];
                    const isNotPair = word.includes("=");
                    if (isNotPair) {
                        const secondWord = words[i + 1];
                        if (secondWord && secondWord.startsWith("=")) {
                            if (secondWord.length > 1) {
                                const newWord = word + secondWord;
                                tokens.push({
                                    type,
                                    content: newWord
                                });
                                i += 1;
                                continue;
                            }
                            const thirdWord = words[i + 2];
                            i += 1;
                            if (thirdWord) {
                                const newWord1 = word + "=" + thirdWord;
                                tokens.push({
                                    type,
                                    content: newWord1
                                });
                                i += 1;
                                continue;
                            }
                        }
                    }
                    if (word.endsWith("=")) {
                        const secondWord1 = words[i + 1];
                        if (secondWord1 && !secondWord1.includes("=")) {
                            const newWord2 = word + secondWord1;
                            tokens.push({
                                type,
                                content: newWord2
                            });
                            i += 1;
                            continue;
                        }
                        const newWord3 = word.slice(0, -1);
                        tokens.push({
                            type,
                            content: newWord3
                        });
                        continue;
                    }
                    tokens.push({
                        type,
                        content: word
                    });
                }
            }
            scanSkipTag(tagName) {
                const { html , position  } = this;
                const safeTagName = tagName.toLowerCase();
                const len = html.length;
                while(position.index < len){
                    const nextTag = html.indexOf("</", position.index);
                    if (nextTag === -1) {
                        this.scanText();
                        break;
                    }
                    jumpPosition(position, html, nextTag);
                    const name = this.scanTag();
                    if (safeTagName === name.toLowerCase()) {
                        break;
                    }
                }
            }
            constructor(html){
                this.tokens = [];
                this.position = initPosition();
                this.html = html;
            }
        };
        LEFT_BRACKET = "{";
        RIGHT_BRACKET = "}";
        CLASS_SELECTOR = ".";
        ID_SELECTOR = "#";
        CHILD_COMBINATOR = ">";
        GENERAL_SIBLING_COMBINATOR = "~";
        ADJACENT_SIBLING_COMBINATOR = "+";
        StyleTagParser = class {
            extractStyle(src) {
                const REG_STYLE = /<style\s?[^>]*>((.|\n|\s)+?)<\/style>/g;
                let html = src;
                html = html.replace(REG_STYLE, (_, $1)=>{
                    const style2 = $1.trim();
                    this.stringToSelector(style2);
                    return "";
                });
                return html.trim();
            }
            stringToSelector(style2) {
                let lb = style2.indexOf(LEFT_BRACKET);
                while(lb > -1){
                    const rb = style2.indexOf(RIGHT_BRACKET);
                    const selectors = style2.slice(0, lb).trim();
                    let content = style2.slice(lb + 1, rb);
                    content = content.replace(/:(.*);/g, function(_, $1) {
                        const t = $1.trim().replace(/ +/g, "+++");
                        return `:${t};`;
                    });
                    content = content.replace(/ /g, "");
                    content = content.replace(/\+\+\+/g, " ");
                    if (!/;$/.test(content)) {
                        content += ";";
                    }
                    selectors.split(",").forEach((src)=>{
                        const selectorList = this.parseSelector(src);
                        this.styles.push({
                            content,
                            selectorList
                        });
                    });
                    style2 = style2.slice(rb + 1);
                    lb = style2.indexOf(LEFT_BRACKET);
                }
            }
            parseSelector(src) {
                const list = src.trim().replace(/ *([>~+]) */g, " $1").replace(/ +/g, " ").replace(/\[\s*([^[\]=\s]+)\s*=\s*([^[\]=\s]+)\s*\]/g, "[$1=$2]").split(" ");
                const selectors = list.map((item)=>{
                    const firstChar = item.charAt(0);
                    const selector = {
                        isChild: firstChar === CHILD_COMBINATOR,
                        isGeneralSibling: firstChar === GENERAL_SIBLING_COMBINATOR,
                        isAdjacentSibling: firstChar === ADJACENT_SIBLING_COMBINATOR,
                        tag: null,
                        id: null,
                        class: [],
                        attrs: []
                    };
                    item = item.replace(/^[>~+]/, "");
                    item = item.replace(/\[(.+?)\]/g, function(_, $1) {
                        const [key, value] = $1.split("=");
                        const all = $1.indexOf("=") === -1;
                        const attr = {
                            all,
                            key,
                            value: all ? null : value
                        };
                        selector.attrs.push(attr);
                        return "";
                    });
                    item = item.replace(/([.#][A-Za-z0-9-_]+)/g, function(_, $1) {
                        if ($1[0] === ID_SELECTOR) {
                            selector.id = $1.substr(1);
                        } else if ($1[0] === CLASS_SELECTOR) {
                            selector.class.push($1.substr(1));
                        }
                        return "";
                    });
                    if (item !== "") {
                        selector.tag = item;
                    }
                    return selector;
                });
                return selectors;
            }
            matchStyle(tagName, el, list) {
                const res = sortStyles(this.styles).reduce((str, { content , selectorList  }, i)=>{
                    let idx = list[i];
                    let selector = selectorList[idx];
                    const nextSelector = selectorList[idx + 1];
                    if ((nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isGeneralSibling) || (nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isAdjacentSibling)) {
                        selector = nextSelector;
                        idx += 1;
                        list[i] += 1;
                    }
                    let isMatch = this.matchCurrent(tagName, el, selector);
                    if (isMatch && selector.isGeneralSibling) {
                        let prev = getPreviousElement(el);
                        while(prev){
                            if (prev.h5tagName && this.matchCurrent(prev.h5tagName, prev, selectorList[idx - 1])) {
                                isMatch = true;
                                break;
                            }
                            prev = getPreviousElement(prev);
                            isMatch = false;
                        }
                    }
                    if (isMatch && selector.isAdjacentSibling) {
                        const prev1 = getPreviousElement(el);
                        if (!prev1 || !prev1.h5tagName) {
                            isMatch = false;
                        } else {
                            const isSiblingMatch = this.matchCurrent(prev1.h5tagName, prev1, selectorList[idx - 1]);
                            if (!isSiblingMatch) {
                                isMatch = false;
                            }
                        }
                    }
                    if (isMatch) {
                        if (idx === selectorList.length - 1) {
                            return str + content;
                        } else if (idx < selectorList.length - 1) {
                            list[i] += 1;
                        }
                    } else {
                        if (selector.isChild && idx > 0) {
                            list[i] -= 1;
                            if (this.matchCurrent(tagName, el, selectorList[list[i]])) {
                                list[i] += 1;
                            }
                        }
                    }
                    return str;
                }, "");
                return res;
            }
            matchCurrent(tagName, el, selector) {
                if (selector.tag && selector.tag !== tagName) return false;
                if (selector.id && selector.id !== el.id) return false;
                if (selector.class.length) {
                    const classList = el.className.split(" ");
                    for(let i = 0; i < selector.class.length; i++){
                        const cls = selector.class[i];
                        if (classList.indexOf(cls) === -1) {
                            return false;
                        }
                    }
                }
                if (selector.attrs.length) {
                    for(let i1 = 0; i1 < selector.attrs.length; i1++){
                        const { all , key , value  } = selector.attrs[i1];
                        if (all && !el.hasAttribute(key)) {
                            return false;
                        } else {
                            const attr = el.getAttribute(key);
                            if (attr !== unquote(value || "")) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            constructor(){
                this.styles = [];
            }
        };
        specialMiniElements = {
            img: "image",
            iframe: "web-view"
        };
        internalCompsList = Object.keys(internalComponents).map((i)=>i.toLowerCase()).join(",");
        isMiniElements = makeMap(internalCompsList, true);
        isInlineElements = makeMap("a,i,abbr,iframe,select,acronym,slot,small,span,bdi,kbd,strong,big,map,sub,sup,br,mark,mark,meter,template,canvas,textarea,cite,object,time,code,output,u,data,picture,tt,datalist,var,dfn,del,q,em,s,embed,samp,b", true);
        isBlockElements = makeMap("address,fieldset,li,article,figcaption,main,aside,figure,nav,blockquote,footer,ol,details,form,p,dialog,h1,h2,h3,h4,h5,h6,pre,dd,header,section,div,hgroup,table,dl,hr,ul,dt", true);
        closingTagAncestorBreakers = {
            li: [
                "ul",
                "ol",
                "menu"
            ],
            dt: [
                "dl"
            ],
            dd: [
                "dl"
            ],
            tbody: [
                "table"
            ],
            thead: [
                "table"
            ],
            tfoot: [
                "table"
            ],
            tr: [
                "table"
            ],
            td: [
                "table"
            ]
        };
        options.html = {
            skipElements: /* @__PURE__ */ new Set([
                "style",
                "script"
            ]),
            voidElements: /* @__PURE__ */ new Set([
                "!doctype",
                "area",
                "base",
                "br",
                "col",
                "command",
                "embed",
                "hr",
                "img",
                "input",
                "keygen",
                "link",
                "meta",
                "param",
                "source",
                "track",
                "wbr"
            ]),
            closingElements: /* @__PURE__ */ new Set([
                "html",
                "head",
                "body",
                "p",
                "dt",
                "dd",
                "li",
                "option",
                "thead",
                "th",
                "tbody",
                "tr",
                "td",
                "tfoot",
                "colgroup"
            ]),
            renderHTMLTag: false
        };
        if (true) {
            if (true) {
                TaroNode.extend("innerHTML", {
                    set (html) {
                        setInnerHTML.call(this, this, html);
                    },
                    get () {
                        return "";
                    }
                });
                if (false) {
                    TaroNode.extend("insertAdjacentHTML", insertAdjacentHTML);
                }
            }
            if (false) {
                TaroNode.extend("cloneNode", cloneNode);
            }
            if (false) {
                TaroNode.extend("contains", contains);
            }
            if (false) {
                TaroElement.extend("getBoundingClientRect", getBoundingClientRectImpl);
            }
            if (false) {
                TaroElement.extend("content", {
                    get () {
                        return getTemplateContent(this);
                    }
                });
            }
        }
        TaroEvent = class {
            stopPropagation() {
                this._stop = true;
            }
            stopImmediatePropagation() {
                this._end = this._stop = true;
            }
            preventDefault() {
                this.defaultPrevented = true;
            }
            get target() {
                var _a, _b;
                const cacheTarget = this.cacheTarget;
                if (!cacheTarget) {
                    const target = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.target) || null);
                    const element = env.document.getElementById(target.id);
                    target.dataset = element !== null ? element.dataset : EMPTY_OBJ;
                    for(const key in (_b = this.mpEvent) === null || _b === void 0 ? void 0 : _b.detail){
                        target[key] = this.mpEvent.detail[key];
                    }
                    this.cacheTarget = target;
                    return target;
                } else {
                    return cacheTarget;
                }
            }
            get currentTarget() {
                var _a, _b, _c, _d;
                const cacheCurrentTarget = this.cacheCurrentTarget;
                if (!cacheCurrentTarget) {
                    const doc = env.document;
                    const currentTarget = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.currentTarget) || null);
                    const element = doc.getElementById(currentTarget.id);
                    const targetElement = doc.getElementById(((_c = (_b = this.mpEvent) === null || _b === void 0 ? void 0 : _b.target) === null || _c === void 0 ? void 0 : _c.id) || null);
                    if (element === null || element && element === targetElement) {
                        this.cacheCurrentTarget = this.target;
                        return this.target;
                    }
                    currentTarget.dataset = element.dataset;
                    for(const key in (_d = this.mpEvent) === null || _d === void 0 ? void 0 : _d.detail){
                        currentTarget[key] = this.mpEvent.detail[key];
                    }
                    this.cacheCurrentTarget = currentTarget;
                    return currentTarget;
                } else {
                    return cacheCurrentTarget;
                }
            }
            constructor(type, opts, event){
                this._stop = false;
                this._end = false;
                this.defaultPrevented = false;
                this.timeStamp = Date.now();
                this.type = type.toLowerCase();
                this.mpEvent = event;
                this.bubbles = Boolean(opts && opts.bubbles);
                this.cancelable = Boolean(opts && opts.cancelable);
            }
        };
        eventsBatch = {};
        FormElement = class extends TaroElement {
            get value() {
                const val = this.props[VALUE];
                return val == null ? "" : val;
            }
            set value(val) {
                this.setAttribute(VALUE, val);
            }
            dispatchEvent(event) {
                if (event.mpEvent) {
                    const val = event.mpEvent.detail.value;
                    if (event.type === CHANGE) {
                        this.props.value = val;
                    } else if (event.type === INPUT) {
                        this.value = val;
                    }
                }
                return super.dispatchEvent(event);
            }
        };
        Performance = class {
            start(id) {
                if (!options.debug) {
                    return;
                }
                this.recorder.set(id, Date.now());
            }
            stop(id) {
                if (!options.debug) {
                    return;
                }
                const now2 = Date.now();
                const prev = this.recorder.get(id);
                this.recorder.delete(id);
                const time = now2 - prev;
                console.log(`${id} \u65F6\u957F\uFF1A ${time}ms`);
            }
            constructor(){
                this.recorder = /* @__PURE__ */ new Map();
            }
        };
        perf = new Performance();
        TaroRootElement = class extends TaroElement {
            get _path() {
                return ROOT_STR;
            }
            get _root() {
                return this;
            }
            enqueueUpdate(payload) {
                this.updatePayloads.push(payload);
                if (!this.pendingUpdate && this.ctx) {
                    this.performUpdate();
                }
            }
            performUpdate(initRender = false, prerender) {
                this.pendingUpdate = true;
                const ctx = this.ctx;
                setTimeout(()=>{
                    const setDataMark = `${SET_DATA} \u5F00\u59CB\u65F6\u95F4\u6233 ${Date.now()}`;
                    perf.start(setDataMark);
                    const data = /* @__PURE__ */ Object.create(null);
                    const resetPaths = new Set(initRender ? [
                        "root.cn.[0]",
                        "root.cn[0]"
                    ] : []);
                    while(this.updatePayloads.length > 0){
                        const { path , value  } = this.updatePayloads.shift();
                        if (path.endsWith("cn")) {
                            resetPaths.add(path);
                        }
                        data[path] = value;
                    }
                    for(const path1 in data){
                        resetPaths.forEach((p)=>{
                            if (path1.includes(p) && path1 !== p) {
                                delete data[path1];
                            }
                        });
                        const value1 = data[path1];
                        if (isFunction(value1)) {
                            data[path1] = value1();
                        }
                    }
                    if (isFunction(prerender)) return prerender(data);
                    this.pendingUpdate = false;
                    let normalUpdate = {};
                    const customWrapperMap = /* @__PURE__ */ new Map();
                    if (initRender) {
                        normalUpdate = data;
                    } else {
                        for(const p in data){
                            const dataPathArr = p.split(".");
                            const found = findCustomWrapper(this, dataPathArr);
                            if (found) {
                                const { customWrapper , splitedPath  } = found;
                                customWrapperMap.set(customWrapper, Object.assign(Object.assign({}, customWrapperMap.get(customWrapper) || {}), {
                                    [`i.${splitedPath}`]: data[p]
                                }));
                            } else {
                                normalUpdate[p] = data[p];
                            }
                        }
                    }
                    const customWrpperCount = customWrapperMap.size;
                    const isNeedNormalUpdate = Object.keys(normalUpdate).length > 0;
                    const updateArrLen = customWrpperCount + (isNeedNormalUpdate ? 1 : 0);
                    let executeTime = 0;
                    const cb = ()=>{
                        if (++executeTime === updateArrLen) {
                            perf.stop(setDataMark);
                            this.flushUpdateCallback();
                            initRender && perf.stop(PAGE_INIT);
                        }
                    };
                    if (customWrpperCount) {
                        customWrapperMap.forEach((data2, ctx2)=>{
                            if (options.debug) {
                                console.log("custom wrapper setData: ", data2);
                            }
                            ctx2.setData(data2, cb);
                        });
                    }
                    if (isNeedNormalUpdate) {
                        if (options.debug) {
                            console.log("page setData:", normalUpdate);
                        }
                        ctx.setData(normalUpdate, cb);
                    }
                }, 0);
            }
            enqueueUpdateCallback(cb, ctx) {
                this.updateCallbacks.push(()=>{
                    ctx ? cb.call(ctx) : cb();
                });
            }
            flushUpdateCallback() {
                const updateCallbacks = this.updateCallbacks;
                if (!updateCallbacks.length) return;
                const copies = updateCallbacks.slice(0);
                this.updateCallbacks.length = 0;
                for(let i = 0; i < copies.length; i++){
                    copies[i]();
                }
            }
            constructor(){
                super();
                this.updatePayloads = [];
                this.updateCallbacks = [];
                this.pendingUpdate = false;
                this.ctx = null;
                this.nodeName = ROOT_STR;
                this.tagName = ROOT_STR.toUpperCase();
            }
        };
        TaroText = class extends TaroNode {
            set textContent(text) {
                MutationObserver.record({
                    target: this,
                    type: "characterData",
                    oldValue: this._value
                });
                this._value = text;
                this.enqueueUpdate({
                    path: `${this._path}.${"v"}`,
                    value: text
                });
            }
            get textContent() {
                return this._value;
            }
            set nodeValue(text) {
                this.textContent = text;
            }
            get nodeValue() {
                return this._value;
            }
            set data(text) {
                this.textContent = text;
            }
            get data() {
                return this._value;
            }
            constructor(value){
                super();
                this.nodeType = 3;
                this.nodeName = "#text";
                this._value = value;
            }
        };
        TaroDocument = class extends TaroElement {
            createElement(type) {
                if (type === ROOT_STR) {
                    return new TaroRootElement();
                }
                const element = controlledComponent.has(type) ? new FormElement() : new TaroElement();
                element.nodeName = type;
                element.tagName = type.toUpperCase();
                return element;
            }
            createElementNS(_svgNS, type) {
                return this.createElement(type);
            }
            createTextNode(text) {
                return new TaroText(text);
            }
            getElementById(id) {
                const el = eventSource.get(id);
                return isUndefined(el) ? null : el;
            }
            querySelector(query) {
                if (/^#/.test(query)) {
                    return this.getElementById(query.slice(1));
                }
                return null;
            }
            querySelectorAll() {
                return [];
            }
            createComment() {
                const textnode = new TaroText("");
                textnode.nodeName = COMMENT;
                return textnode;
            }
            get defaultView() {
                return env.window;
            }
            constructor(){
                super();
                this.createEvent = createEvent;
                this.nodeType = 9;
                this.nodeName = DOCUMENT_ELEMENT_NAME;
            }
        };
        if (true) {
            let createDocument = function() {
                const doc = new TaroDocument();
                const documentCreateElement = doc.createElement.bind(doc);
                const html = documentCreateElement(HTML);
                const head = documentCreateElement(HEAD);
                const body = documentCreateElement(BODY);
                const app = documentCreateElement(APP);
                app.id = APP;
                const container = documentCreateElement(CONTAINER);
                doc.appendChild(html);
                html.appendChild(head);
                html.appendChild(body);
                body.appendChild(container);
                container.appendChild(app);
                doc.documentElement = html;
                doc.head = head;
                doc.body = body;
                return doc;
            };
            document$1 = env.document = createDocument();
        } else {
            document$1 = env.document;
        }
        machine = "Macintosh";
        arch = "Intel Mac OS X 10_14_5";
        engine = "AppleWebKit/534.36 (KHTML, like Gecko) NodeJS/v4.1.0 Chrome/76.0.3809.132 Safari/534.36";
        msg = "(" + machine + "; " + arch + ") " + engine;
        nav = false ? env.window.navigator : {
            appCodeName: "Mozilla",
            appName: "Netscape",
            appVersion: "5.0 " + msg,
            cookieEnabled: true,
            mimeTypes: [],
            onLine: true,
            platform: "MacIntel",
            plugins: [],
            product: "Taro",
            productSub: "20030107",
            userAgent: "Mozilla/5.0 " + msg,
            vendor: "Joyent",
            vendorSub: ""
        };
        (function() {
            let loadTime;
            if (typeof performance !== "undefined" && performance !== null && performance.now) {
                now = ()=>performance.now();
            } else if (Date.now) {
                loadTime = Date.now();
                now = ()=>Date.now() - loadTime;
            } else {
                loadTime = new Date().getTime();
                now = ()=>new Date().getTime() - loadTime;
            }
        })();
        lastTime = 0;
        _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame !== null ? requestAnimationFrame : function(callback) {
            const _now = now();
            const nextTime = Math.max(lastTime + 16, _now);
            return setTimeout(function() {
                callback(lastTime = nextTime);
            }, nextTime - _now);
        };
        _caf = typeof cancelAnimationFrame !== "undefined" && cancelAnimationFrame !== null ? cancelAnimationFrame : function(seed) {
            clearTimeout(seed);
        };
        eventCenter = hooks.call("getEventCenter", Events);
        if (true) {
            class Window extends Events {
                get document() {
                    return env.document;
                }
                addEventListener(event, callback) {
                    if (!isString(event)) return;
                    this.on(event, callback, null);
                }
                removeEventListener(event, callback) {
                    if (!isString(event)) return;
                    this.off(event, callback, null);
                }
                setTimeout(...args) {
                    return setTimeout(...args);
                }
                clearTimeout(...args) {
                    return clearTimeout(...args);
                }
                constructor(){
                    super();
                    this.navigator = nav;
                    this.requestAnimationFrame = _raf;
                    this.cancelAnimationFrame = _caf;
                    this.getComputedStyle = getComputedStyle;
                    const globalProperties = [
                        ...Object.getOwnPropertyNames(global || {}),
                        ...Object.getOwnPropertySymbols(global || {})
                    ];
                    globalProperties.forEach((property)=>{
                        if (property === "atob" || property === "document") return;
                        if (!Object.prototype.hasOwnProperty.call(this, property)) {
                            this[property] = global[property];
                        }
                    });
                    this.Date || (this.Date = Date);
                }
            }
            window$1 = env.window = new Window();
        } else {
            window$1 = env.window;
        }
        SVGElement = class extends TaroElement {
        };
        Current = {
            app: null,
            router: null,
            page: null
        };
        getCurrentInstance = ()=>Current;
        instances = /* @__PURE__ */ new Map();
        pageId = incrementId();
        nextTick = (cb, ctx)=>{
            var _a, _b, _c;
            const router = Current.router;
            const timerFunc = ()=>{
                setTimeout(function() {
                    ctx ? cb.call(ctx) : cb();
                }, 1);
            };
            if (router !== null) {
                let pageElement = null;
                const path = router.$taroPath;
                pageElement = env.document.getElementById(path);
                if (pageElement === null || pageElement === void 0 ? void 0 : pageElement.pendingUpdate) {
                    if (false) {
                        (_c = (_b = (_a = pageElement.firstChild) === null || _a === void 0 ? void 0 : _a["componentOnReady"]) === null || _b === void 0 ? void 0 : _b.call(_a).then(()=>{
                            timerFunc();
                        })) !== null && _c !== void 0 ? _c : timerFunc();
                    } else {
                        pageElement.enqueueUpdateCallback(cb, ctx);
                    }
                } else {
                    timerFunc();
                }
            } else {
                timerFunc();
            }
        };
    }
});
export { MutationObserver, incrementId, eventSource, hydrate, TaroNode, Style, TaroElement, options, TaroEvent, createEvent, eventHandler, FormElement, TaroRootElement, TaroText, document$1, getComputedStyle, nav, now, _raf, _caf, eventCenter, window$1, SVGElement, Current, getCurrentInstance, injectPageInstance, getPageInstance, removePageInstance, addLeadingSlash, safeExecute, stringify, createPageConfig, createComponentConfig, createRecursiveComponentConfig, nextTick, runtime_esm_exports, init_runtime_esm };
