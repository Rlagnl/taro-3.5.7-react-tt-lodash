var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable dot-notation */
import { createPageConfig, Current, eventCenter, hooks, stringify } from '@tarojs/runtime';
import { Action as LocationAction } from 'history';
import UniversalRouter from 'universal-router';
import { history, prependBasename } from '../history';
import { addLeadingSlash, routesAlias, stripBasename } from '../utils';
import { setTitle } from '../utils/navigate';
import { RouterConfig } from '.';
import PageHandler from './page';
import stacks from './stack';
export function createRouter(app, config, framework) {
    var _a, _b;
    RouterConfig.config = config;
    const handler = new PageHandler(config);
    routesAlias.set(handler.router.customRoutes);
    const basename = handler.router.basename;
    const routes = handler.routes.map(route => {
        const routePath = addLeadingSlash(route.path);
        const paths = routesAlias.getAll(routePath);
        return {
            path: paths.length < 1 ? routePath : paths,
            action: route.load
        };
    });
    const router = new UniversalRouter(routes, { baseUrl: basename || '' });
    const launchParam = {
        path: handler.homePage,
        query: handler.getQuery(stacks.length),
        scene: 0,
        shareTicket: '',
        referrerInfo: {}
    };
    eventCenter.trigger('__taroRouterLaunch', launchParam);
    (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, launchParam);
    app.onError && window.addEventListener('error', e => { var _a; return (_a = app.onError) === null || _a === void 0 ? void 0 : _a.call(app, e.message); });
    const render = ({ location, action }) => __awaiter(this, void 0, void 0, function* () {
        var _c, _d, _e, _f, _g;
        handler.pathname = decodeURI(location.pathname);
        eventCenter.trigger('__taroRouterChange', {
            toLocation: {
                path: handler.pathname
            }
        });
        let element, params;
        try {
            const result = yield router.resolve(handler.router.forcePath || handler.pathname);
            [element, , params] = yield Promise.all(result);
        }
        catch (error) {
            if (error.status === 404) {
                (_c = app.onPageNotFound) === null || _c === void 0 ? void 0 : _c.call(app, {
                    path: handler.pathname
                });
            }
            else if (/Loading hot update .* failed./.test(error.message)) {
                // NOTE: webpack5 与 prebundle 搭配使用时，开发环境下初次启动时偶发错误，由于 HMR 加载 chunk hash 错误，导致热更新失败
                window.location.reload();
            }
            else {
                throw new Error(error);
            }
        }
        if (!element)
            return;
        const pageConfig = handler.pageConfig;
        let enablePullDownRefresh = ((_d = config === null || config === void 0 ? void 0 : config.window) === null || _d === void 0 ? void 0 : _d.enablePullDownRefresh) || false;
        if (pageConfig) {
            document.title = (_e = pageConfig.navigationBarTitleText) !== null && _e !== void 0 ? _e : document.title;
            setTitle((_f = pageConfig.navigationBarTitleText) !== null && _f !== void 0 ? _f : document.title);
            if (typeof pageConfig.enablePullDownRefresh === 'boolean') {
                enablePullDownRefresh = pageConfig.enablePullDownRefresh;
            }
        }
        const currentPage = Current.page;
        const pathname = handler.pathname;
        let shouldLoad = false;
        if (action === 'POP') {
            // NOTE: 浏览器事件退后多次时，该事件只会被触发一次
            const prevIndex = stacks.getPrevIndex(pathname);
            const delta = stacks.getDelta(pathname);
            // NOTE: Safari 内核浏览器在非应用页面返回上一页时，会触发额外的 POP 事件，此处需避免当前页面被错误卸载
            if (currentPage !== stacks.getItem(prevIndex)) {
                handler.unload(currentPage, delta, prevIndex > -1);
                if (prevIndex > -1) {
                    handler.show(stacks.getItem(prevIndex), pageConfig, prevIndex);
                }
                else {
                    shouldLoad = true;
                }
            }
        }
        else {
            if (handler.isTabBar) {
                if (handler.isSamePage(currentPage))
                    return;
                const prevIndex = stacks.getPrevIndex(pathname, 0);
                handler.hide(currentPage);
                if (prevIndex > -1) {
                    // NOTE: tabbar 页且之前出现过，直接复用
                    return handler.show(stacks.getItem(prevIndex), pageConfig, prevIndex);
                }
            }
            else if (action === 'REPLACE') {
                const delta = stacks.getDelta(pathname);
                // NOTE: 页面路由记录并不会清空，只是移除掉缓存的 stack 以及页面
                handler.unload(currentPage, delta);
            }
            else if (action === 'PUSH') {
                handler.hide(currentPage);
            }
            shouldLoad = true;
        }
        if (shouldLoad || stacks.length < 1) {
            const el = (_g = element.default) !== null && _g !== void 0 ? _g : element;
            const loadConfig = Object.assign({}, pageConfig);
            const stacksIndex = stacks.length;
            delete loadConfig['path'];
            delete loadConfig['load'];
            const page = createPageConfig(enablePullDownRefresh ? hooks.call('createPullDownComponent', el, location.pathname, framework, handler.PullDownRefresh) : el, pathname + stringify(handler.getQuery(stacksIndex)), {}, loadConfig);
            if (params)
                page.options = params;
            return handler.load(page, pageConfig, stacksIndex);
        }
    });
    const routePath = addLeadingSlash(stripBasename(history.location.pathname, handler.basename));
    if (routePath === '/') {
        history.replace(prependBasename(handler.homePage + history.location.search));
    }
    render({ location: history.location, action: LocationAction.Push });
    (_b = app.onShow) === null || _b === void 0 ? void 0 : _b.call(app, launchParam);
    return history.listen(render);
}
